///// Shintani Algorithms + Enumerations of Totally positive elements in ideals /////////
// Todo Massive clean up

// Helper Functions
intrinsic EmbedNumberField(nu::RngOrdElt, places::SeqEnum) -> SeqEnum
  { Input: nu an element of ZF where F is totally real
    Output: A tuple of the real embeddings of nu in RR}
  return [Evaluate(nu, pl) : pl in places];
end intrinsic;


intrinsic Slope(alpha::RngOrdElt) -> FldReElt
  { Input:  alpha, an element of ZF for F a totally real quadratic number field
    Output: The "slope" defined by alpha: sigma_2(alpha)/sigma_1(alpha) where sigma_i is the ith embedding of F}
  OK := Parent(alpha);
  K := NumberField(OK);
  places := InfinitePlaces(K);
  return Evaluate(alpha, places[2]) / Evaluate(alpha, places[1]);
end intrinsic;


// Rearranges the basis for an ideal so that the second basis vector has trace 0
intrinsic TraceBasis(bb::RngOrdFracIdl) -> SeqEnum
  {Given a fractional ideal bb, returns a basis (a,b) in Smith normal form where Trace(a) = n and Trace(b) = 0}
  basis := Basis(bb);
  ZF := Parent(basis[2]);
  Tr := Matrix([[Trace(basis[i]) : i in [1..#basis]]]);
  _,_,Q := SmithForm(Tr);
  ChangeofBasisMatrix := ChangeRing(Q,ZF);
  NewBasis := Eltseq(Vector(basis)*ChangeofBasisMatrix);
  return NewBasis;
end intrinsic;




///////////////////////////////////////////////////
//                                               //
//   Enumeration of Totally Positive elements    //
//                                               //
///////////////////////////////////////////////////

// Totally Positive Elements in an Ideal 
/* Idea: I've hopefully obtained basis {a,b} for the ideal bb where Tr(a) = n and Tr(b) = 0. Elements in ideal will look like xa+yb where x,y \in Z and have embedding xa_1+ yb_1 and xa_2+ yb_2.  All totally positive elements of given trace t will satisfy 
1).    t = Tr(xa+yb)    <=>   t = xn    
2).    xa+yb >> 0.     <=>   y > -x*a_1/b_1   and  y > -x*a_2/b_2  
Eq 1) determines the value for x while Eq 2) allows us to loop over values of y */

intrinsic PositiveElementsOfTrace(bb::RngOrdFracIdl, t::RngIntElt) -> SeqEnum[RngOrdFracIdl]
  {Given bb a fractional ideal, t a trace bound, returns the totally positive elements of bb with trace t.}
  Basis := TraceBasis(bb);
  places := InfinitePlaces(NumberField(Parent(Basis[1])));
  SmallestTrace := Trace(Basis[1]);
  T := [];
  if t mod SmallestTrace eq 0 then
    x := t div SmallestTrace;
    a_1 := Evaluate(Basis[1],places[1]); b_1 := Evaluate(Basis[2],places[1]);
    a_2 := Evaluate(Basis[1],places[2]); b_2 := Evaluate(Basis[2],places[2]);
    Lower := Ceiling(Min(-x*a_1/b_1,-x*a_2/b_2));
    Upper := Floor(Max(-x*a_1/b_1,-x*a_2/b_2));
    for y in [Lower .. Upper] do
      /* Append(~T, [x*Basis[1]+y*Basis[2]]); */
      Append(~T, x*Basis[1]+y*Basis[2]);
    end for;
  end if;
  return T;
end intrinsic;


intrinsic BoundedRepresentatives(M::ModFrmHilDGRng, bb::RngOrdFracIdl, XLBound::Any, YLBound::Any, XUBound::Any, YUBound::Any) -> SeqEnum
  {Enumerates all elements c in bb with 0 < c_1 < Xbound and  0< c_2 < Ybound}    
  require forall{i : i in [XUBound,YUBound,XLBound,YLBound] | Type(i) eq RngIntElt or Type(i) eq FldReElt }: "Bounds must be integers or real numbers";
  Basis := TraceBasis(bb);
  F := BaseField(M);
  ZF := Integers(M);
  places := places(M);
  // Why isn't trace basis already oriented?
  // Since Tr(Basis[2]) = 0 this will guarentees signs of the form -,+
  if Evaluate(Basis[2],places[1]) lt 0 then
    Basis := [Basis[1], -Basis[2]];
  end if;
  // Precomputationss 
  a_1 := Evaluate(Basis[1],places[1]); b_1 := Evaluate(Basis[2],places[1]);
  a_2 := Evaluate(Basis[1],places[2]); b_2 := Evaluate(Basis[2],places[2]);
  // List of all Elements
  T := [];
  TraceLBound := Ceiling(XLBound+YLBound);
  TraceUBound := Floor(XUBound+YUBound);
  for x in [TraceLBound .. TraceUBound] do 
    Lower := Ceiling(Max((XLBound-x*a_1)/b_1,(YUBound-x*a_2)/b_2));
    Upper := Floor(Min((XUBound-x*a_1)/b_1,(YLBound-x*a_2)/b_2));
    for y in [Lower .. Upper] do
      Append(~T, x*Basis[1]+y*Basis[2]);
    end for;
  end for;
  return T;
end intrinsic;


///////////////////////////////////////////////////
//                                               //
//          Shintani Domain algorithms           //
//                                               //
///////////////////////////////////////////////////

// Helper Functions
// Returns the slopes of the upper and lower walls for the Shintani Domain
intrinsic ShintaniWalls(ZF::RngOrd) -> Any
  {returns lower and upper walls of the Shintani domain}
  require Degree(ZF) eq 2: "only implemented for quadratic fields";
  D := Discriminant(ZF);
  F := QuadraticField(D);
  places := InfinitePlaces(F);
  eps := FundamentalUnit(F);
  if Norm(eps) eq -1 then
    // In this case CK = CK^+ so the totally positive units are squares i.e. the subgroup generated by eps^2
    eps := eps^2;
  else 
    if not IsTotallyPositive(eps) then
      // In this case CK not equal to CK^+ so there are no units of mixed signs. If the fundamental unit is not totally positive we multiply by -1 
      eps := -1*eps;
    end if;
  end if;
  eps1 := Evaluate(eps, places[1]);
  eps2 := Evaluate(eps, places[2]);
  // always returns smallest first
  if eps1/eps2 le eps2/eps1 then
    return Sqrt(eps1/eps2), Sqrt(eps2/eps1);
  else
    return Sqrt(eps2/eps1), Sqrt(eps1/eps2);
  end if;
end intrinsic;


// Elements of the Shintani Domain with trace t
/* Idea: I've hopefully obtained basis {a,b} for the ideal bb where Tr(a) = n and Tr(b) = 0. Elements in ideal will look like xa+yb where x,y \in Z and have embedding xa_1+ yb_1 and xa_2+ yb_2. All totally positive elements of given trace t will satisfy
1).    t = Tr(xa+yb)    <=>   t = xn
2).    C_1 < (xa_1+yb_1)/(xa_2+yb_2) < C_2.     <=>   (C_1*x*a_2 -x*a_1)/(b_1-C_1*b_2) < y   and  y < (C_2*x*a_2 -x*a_1)/(b_1-C_2*b_2)
where C1 and C2 are the slope bounds on the shintani domain. Eq 1) determines the value for x while Eq 2) allows us to loop over values of y */
intrinsic ShintaniDomainOfTrace(bb::RngOrdFracIdl, t::RngIntElt) -> SeqEnum[RngOrdFracIdl]
  {Given bb a fractional ideal, t a trace bound, returns the totally positive elements of bb in the balanced Shintani cone with trace t.}  
  Basis := TraceBasis(bb);
  F := NumberField(Parent(Basis[1]));
  ZF := Integers(F);
  places := InfinitePlaces(F);
  if t eq 0 then
    return [ZF!0];
  else  
    // Orienting basis
    if Evaluate(Basis[2],places[2]) lt 0 then
      Basis := [Basis[1], -Basis[2]];
    end if;
    SmallestTrace := Trace(Basis[1]);
    T := [];
    if t mod SmallestTrace eq 0 then
      x := t div SmallestTrace;
      C1,C2 := ShintaniWalls(ZF);
      a1 := Evaluate(Basis[1],places[1]); b1 := Evaluate(Basis[2],places[1]);
      a2 := Evaluate(Basis[1],places[2]); b2 := Evaluate(Basis[2],places[2]);
      Lower := (C2*x*a2 -x*a1)/(b1-C2*b2); Upper := (C1*x*a2 -x*a1)/(b1-C1*b2); 
      // Magma has some extreme problems with .999999999 /= 1. That is why this is defined in a terrible manner. It removes points that lie on the upper wall
      prec := Precision(Lower);
      if Abs(Round(Lower) - Lower) lt 10^(-prec/2) then Lower := Round(Lower); else Lower := Ceiling(Lower); end if;
      if Abs(Round(Upper) - Upper) lt 10^(-prec/2) then Upper := Round(Upper)-1; else Upper := Floor(Upper); end if;
      for y in [Lower .. Upper] do
        Append(~T, x*Basis[1]+y*Basis[2]);
      end for;
    end if;
    return T;
  end if;
end intrinsic;


///////////////////////////////////////////////////
//                                               //
//          Shintani Reduction Algorithms        //
//                                               //
///////////////////////////////////////////////////


// Shintani Reduction Algorithm 1 (Currently in use)
// The Shintani Domain above is stored in an array and this looks up the ideal
intrinsic ReduceShintani(nu::RngOrdElt, bb::RngOrdFracIdl, M::ModFrmHilDGRng) -> SeqEnum
  {Speed up for Reduce Shintani}
  ZF := Integers(M);
  I := nu*ZF;
  ShintaniRep := ReduceIdealToShintaniRep(M)[bb][I];
  return ShintaniRep;
end intrinsic;


// Shintani Reduction Algorithm 2
intrinsic ReduceShintaniMinimizeTrace(nu::RngOrdElt) -> Any
  {}
  if nu eq 0 then
    return Parent(nu)!0;
  end if;
  // assert IsTotallyPositive(nu);

 // Preliminaries
  ZF := Parent(nu);
  F := NumberField(ZF);
  // Asserts
  require IsTotallyPositive(nu): "nu must be totally positive";
  require Degree(F) eq 2: "Shintani domains only implemented for quadratic fields";
  // Fundamental unit
  U,mU := UnitGroup(ZF);
  eps := mU(U.2); // Assuming quadratic field then this should be the fundamental unit.
  places := InfinitePlaces(F);
  // Replace with generator for totally positive units
  sign_eps := Set(Signature(F!eps)); // Signs of fundamental unit: {1,-1}, {-1}, or {1}.
  if sign_eps eq {-1} then // Case 1: Sign(eps) = [-1,-1] so we replace with -eps.
    eps := -eps;
  elif sign_eps eq {1,-1} then // Case 2: Sign(eps) = [-1,1] so we replace with eps^2.
    eps := eps^2;
  else // Case 3: Sign(eps) = [1,1] so we leave it eps.
    eps := eps;
  end if;

  // ZF := Parent(nu);
  // D:=Discriminant(ZF);
  // F:=QuadraticField(D);
  // ZF:=Integers(F);
  // //F := NumberField(ZF);
  // places := InfinitePlaces(F);
  // eps := FundamentalUnit(ZF);
  // // determine signs of eps and make eps totally positive
  // eps_RR := EmbedNumberField(eps, places);
  // assert #eps_RR eq 2; // only for quadratic fields right now
  // pos_count := 0;
  // for i := 1 to #places do
  //   if eps_RR[i] gt 0 then
  //     pos_count +:= 1;
  //   end if;
  // end for;
  // if pos_count eq 0 then
  //   eps := -eps;
  // elif pos_count eq 1 then
  //   eps := eps^2;
  // else
  //   eps := eps;
  // end if;
  eps_RR := EmbedNumberField(eps, places);
  slope_eps := Slope(eps);
  slope_nu := Slope(nu);
  // TODO: do we know calculus?
  // r := -Floor( RealField(100)!(Log(slope_nu)/Log(slope_eps)) ); // old formula
  /* r := Integers()!((1/2)*Round(Log(RealField(100)!slope_nu)/Log(RealField(100)!eps_RR[1]))); */
  RR := RealField(100);
  ratio := RR!(1/2)*Log(RR!slope_nu)/Log(RR!eps_RR[1]);
  ratio_ceiling := Ceiling(ratio);
  ratio_floor := Floor(ratio);
  nu_ceiling := eps^ratio_ceiling*nu;
  nu_floor := eps^ratio_floor*nu;
  slope_nu_ceiling := Slope(nu_ceiling);
  slope_nu_floor := Slope(nu_floor);
  slopes := [slope_nu_floor, slope_nu_ceiling];
  nus := [nu_floor, nu_ceiling];
  ParallelSort(~slopes, ~nus);
  if IsShintaniReduced(nus[1]) then
    return nus[1];
  else
    assert IsShintaniReduced(nus[2]);
    return nus[2];
  end if;
end intrinsic;


// Test if an element is Shintani reduced 
intrinsic IsShintaniReduced(nu::RngOrdElt) -> BoolElt
  {}
  // zero is Shintani Reduced
  if nu eq Parent(nu)!0 then
    return true;
  end if;
  // wall1<wall2
  wall1, wall2 := ShintaniWalls(Parent(nu));
  slope := Slope(nu);
  prec := Precision(Parent(slope));
  // walls with fuzz
  if (wall1-10^(-prec/2) le slope) and (slope le wall2+10^(-prec/2)) then
    return true;
  else
    return false;
  end if;
end intrinsic;

/////////////////////// Totally positive associate /////////////////

intrinsic TotallyPositiveAssociate(M::ModFrmHilDGRng, gen::RngOrdElt) -> RngOrdElt
  {Finds a totally positive associate to the given element}
  U := UnitGroup(M);
  mU := UnitGroupMap(M);
  F := BaseField(M);
  ZF := Integers(M);
  UnitGenerators := [F!(mU(u)) : u in Generators(U)];
  UnitSignatures := [Signature(u) : u in UnitGenerators];
  
  // function 1 => 0 and -1 => 1;
  h := function(x); 
    if x eq 1 then return 0; else return 1; end if;
  end function;

  GenSignature := [ h(i) : i in Signature(F!gen)];
  // if not totally positive
  if exists{i : i in GenSignature | i eq 1} then 
    UnitSignatures := [[h(i) : i in j] : j in UnitSignatures];
    F2 := GF(2);
    Mat := Matrix(F2,UnitSignatures);
    V := Vector(F2,GenSignature);
    X := Solution(Mat,V);
    UNIT := &*[UnitGenerators[i] : i in [1..#Generators(U)] | X[i] ne 0 ];
    gen := ZF!(gen*UNIT);
  end if;
  return gen;
end intrinsic;

intrinsic Signature(a::RngOrdElt) -> SeqEnum
  {}
  R := Parent(a);
  return Signature(FieldOfFractions(R)!a);
end intrinsic;

intrinsic TotallyPositiveUnits(R::Rng) -> SeqEnum
  {}
  U, mp := UnitGroup(R);
  // Stupid function, the isomorphism mu_2 -> ZZ/2*ZZ
  hiota := function(u);
    if u eq -1 then
      return 1;
    else
      return 0;
    end if;
  end function;

  F := NumberField(R);
  UZd := AbelianGroup([2 : i in [1..Degree(F)]]);
  phi := hom<U -> UZd | [[hiota(Sign(Evaluate(mp(U.i), v))) : v in RealPlaces(F)] : i in [1..#Generators(U)]]>;
  K := Kernel(phi);
  return K, mp;
end intrinsic;

/////////////////////// Conversion Functions /////////////////////


// Conversion : Shintani elements < = > Ideals
// Converts pairs (bb,nu) <-> (bb,n) based on the set of representatives bb for Cl^+(F)
intrinsic IdealToShintaniRepresentative(M::ModFrmHilDGRng, bb::RngOrdIdl, nn::RngOrdIdl) -> ModFrmHilDElt
  {Takes a representative [bb] in Cl^+(F) and an integral ideal n in ZF with [n] = [bb^(-1)] and returns Shintani representative (nu) = n*bb}
  F := BaseField(M);
  ZF := Integers(M);
  dd := Different(ZF);
  bbp := bb*(dd)^-1;
  mp := NarrowClassGroupMap(M);
  require IsIdentity((nn*bbp)@@mp): "The ideals nn and bb must be inverses in CL+(F)";
  bool, gen := IsPrincipal(nn*bbp);
  // This is hardcoded for quadratic Fields.
  gen := TotallyPositiveAssociate(M,gen);
  ShintaniGenerator := ReduceShintaniMinimizeTrace(gen);
  return ShintaniGenerator;
end intrinsic;

// Conversion : Shintani elements < = > Ideals
// Converts nu <-> n, without needing bb as input 
intrinsic IdealToShintaniRepresentative(M::ModFrmHilDGRng, nn::RngOrdIdl) -> RngOrdElt
  {Takes a representative [bb] in Cl^+(F) and an integral ideal n in ZF with [n] = [bb^(-1)] and returns Shintani representative (nu) = n*bb}
  F := BaseField(M);
  mp := NarrowClassGroupMap(M);
  bbp := mp(-(nn @@ mp)); // bb' is inverse of nn in narrow class group
  bool, gen := IsPrincipal(nn*bb);
  assert bool;
  // This is hardcoded for quadratic Fields.
  gen := TotallyPositiveAssociate(M,gen);
  return ReduceShintaniMinimizeTrace(gen);
end intrinsic;

// Converts nus to nns
intrinsic ShintaniRepresentativeToIdeal(M::ModFrmHilDGRng, bb::RngOrdFracIdl, nu::RngOrdElt) -> RngOrdIdl
  {Takes a representative [bb^(-1)] in Cl^+(F) and a nu in bb_+ and returns the integral ideal n = bb^(-1)*(nu) in ZF}
  if not IsDefined(M`ShintaniRepsIdeal[bb], nu) then
    R := M`Integers;
    dd := Different(R);
    bbp := bb*(dd^-1);
    M`ShintaniRepsIdeal[bb][nu] := NicefyIdeal(nu*bbp^(-1));
  end if;
  return M`ShintaniRepsIdeal[bb][nu];
end intrinsic;

intrinsic PopulateShintaniRepsIdeal(M::ModFrmHilDGRng, bb::RngOrdFracIdl, nus::SetEnum[RngOrdElt])
 {populates ShintaniRepsIdeal[bb][nu] for nu in nus}
  bbinv := bb^(-1);
  for nu in nus diff Keys(M`ShintaniRepsIdeal[bb]) do
    // See ShintaniRepresentativeToIdeal
    M`ShintaniRepsIdeal[bb][nu] := NicefyIdeal(nu*bbinv);
  end for;
end intrinsic;



/// Assorted Shintani Shenanigans ////////

/* 
intrinsic ReduceShintaniComputeIdeal(nu::RngOrdElt, bb::RngOrdFracIdl, shintani_reps::Assoc) -> Any
  {}
  reps := [];
  for t in Keys(shintani_reps[bb]) do
    reps cat:= shintani_reps[bb][t];
  end for;
  return ReduceShintaniComputeIdeal(nu, reps);
end intrinsic;

intrinsic ReduceShintaniComputeIdeal(nu::RngOrdElt, shintani_reps::SeqEnum[RngOrdElt]) -> Any
  {}
  if nu eq 0 then
    return Parent(nu)!0;
  end if;
  assert IsTotallyPositive(nu);
  ZF := Parent(nu);
  nu_ideal := ideal<ZF|nu>;
  shintani_ideals := [ideal<ZF|a> : a in shintani_reps];
  matches := [];
  for i := 1 to #Keys(shintani_reps) do
    I := ideal<ZF|shintani_reps[i]>;
    if nu_ideal eq I then
      Append(~matches, [* I, i *]);
    end if;
  end for;
  assert #matches eq 1;
  return shintani_reps[matches[1][2]];
end intrinsic;
*/

/* intrinsic ReduceShintani(nu::RngOrdElt, bb::RngOrdFracIdl, shintani_reps::Assoc) -> Any */
  /* {} */
  /* nu_reduced_by_ideal := ReduceShintaniComputeIdeal(nu, bb, shintani_reps); */
  /* nu_reduced_by_trace := ReduceShintaniMinimizeTrace(nu); */
  /* return nu_reduced_by_ideal; */
  // sanity check using trace when ready
  /* if nu_reduced_by_ideal eq nu_reduced_by_trace then */
  /*   return nu_reduced_by_ideal; */
  /* else */
  /*   error_message := Sprintf("Shintani walls?\n"); */
  /*   error_message *:= Sprintf("nu using ideals = %o\n", nu_reduced_by_ideal); */
  /*   error_message *:= Sprintf("Trace(nu using ideals) = %o\n", Trace(nu_reduced_by_ideal)); */
  /*   error_message *:= Sprintf("nu using trace = %o\n", nu_reduced_by_trace); */
  /*   error_message *:= Sprintf("Trace(nu using trace) = %o\n", Trace(nu_reduced_by_trace)); */
  /*   error error_message; */
  /* end if; */
/* end intrinsic; */

/*
intrinsic ReduceShintani(pair::SeqEnum, bb::RngOrdFracIdl, shintani_reps::Assoc) -> SeqEnum
  {}
  assert #pair eq 2;
  return [ReduceShintani(nu, bb, shintani_reps) : nu in pair];
end intrinsic;

intrinsic IdealToShintaniRepresentative(M::ModFrmHilD, nn::RngOrdIdl) -> Any
  {}
  Cl := NarrowClassGroup(M);
  mp := NarrowClassGroupMap(M);
  mp_inv := Inverse(mp);
  bb := mp(-mp_inv(nn));
  bl, nu := IsPrincipal(nn*bb); // will this always give a totally positive generator? probably not
  assert bl;
  assert IsTotallyPositive(nu);
  return ReduceShintani(nu, bb, ShintaniReps(M)), bb;
end intrinsic; */




