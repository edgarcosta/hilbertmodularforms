freeze;

// Infrastucture that's useful in debugging 
// (and in general, but this is just a hasty version)

// Steve Donnelly, Aug 07

import "../AlgQuat/enumerate.m" : ZBasisInternal;

intrinsic Lattice(seq::SeqEnum[AlgAssVOrd]) -> Lat, Map
{For internal use. Creates the lattice generated by the given (independent) elements}

  A := Universe(seq);
  require Type(BaseField(A)) eq FldOrd : "Elements must be in the algebra over the FldOrd";
  V, AtoV := VectorSpaceOverQ(A);
  assert #seq eq Dimension(V);
  L := LatticeWithBasis(Matrix(Rationals(), Dimension(V), Dimension(V),
                                            [Eltseq(zb@AtoV) : zb in ZBasis(O)])); 
  return L, AtoV;                                  
end intrinsic;
 
intrinsic Lattice(O::AlgAssVOrd) -> Lat, Map
{For internal use. Maps O bijectively to a lattice inside the VectorSpaceOverQ of Algebra(O)}

  A := Algebra(O);
  V, AtoV := VectorSpaceOverQ(A);
  ZBmat := Matrix(Rationals(), Dimension(V), Dimension(V), 
                               [Eltseq(zb@AtoV) : zb in ZBasis(O)]);
  L := LatticeWithBasis(ZBmat);
  OtoL := map< O -> L | a :-> L! (a @ AtoV),
                        v :-> O! (Eltseq(v) @@ AtoV) >; 
  assert &and[ O!zb eq (zb @ OtoL @@ OtoL) : zb in ZBasis(O)];
  return L, OtoL;
end intrinsic;

intrinsic Lattice(I::AlgAssVOrdIdl) -> Lat, Map
{For internal use. Maps a (fractional) ideal I bijectively to a lattice 
 inside the VectorSpaceOverQ of Algebra(I)}

  A := Algebra(I);
  V, AtoV := VectorSpaceOverQ(A);
  ZBmat := Matrix(Rationals(), Dimension(V), Dimension(V), 
                               [Eltseq(zb@AtoV) : zb in ZBasis(I)]);
  L := LatticeWithBasis(ZBmat);
  /*
  // stupid, stupid map problem ... for some reason the following is not allowed
  ItoL := map< I -> L | a :-> L! (a @ AtoV),
                        v :-> Eltseq(v) @@ AtoV >; 
  */
  ItoL := func< a | L! (a @ AtoV) >;
  LtoI := func< v | Eltseq(v) @@ AtoV >;  // image is in A = Algebra(I)
  assert &and[ a eq zb where a is (zb @ ItoL @ LtoI) : zb in ZBasis(I)];
  return L, ItoL, LtoI;
end intrinsic;

intrinsic CheckOrder(O::AlgAssVOrd : Maximal:=false)
{For internal use. For checking whether all is well with an order}

  A := Algebra(O);
  ZB := ZBasis(O);
  for zb in ZB do assert A!zb in O; end for;
  for zb1, zb2 in ZB do assert A!(zb1*zb2) in O; end for; 
  assert O eq Order(ZB);
  // check discriminant(s)
  assert assigned O`Discriminant eq assigned O`FactoredDiscriminant; 
  if assigned O`Discriminant then
    assert O`Discriminant eq &*[PowerIdeal(BaseRing(O))| t[1]^t[2] : t in O`FactoredDiscriminant];
    assert O`Discriminant eq Discriminant(O:Recompute); 
  end if;
  if Maximal or assigned O`IsMaximal and O`IsMaximal then 
    assert forall{t: t in O`FactoredDiscriminant | t[2] eq 1};
  end if;
end intrinsic;

intrinsic CheckIdeal(I::AlgAssVOrdIdl : Use_in:=true, UseLattice:=false)
{For internal use. For checking whether all is well with an ideal}

  // Is UseLattice option still needed? (the point was to avoid 'in')
  if not Use_in then UseLattice:=true; end if;
  O := Order(I);  // I was defined as an O-ideal
  ZB := ZBasis(I);  
  assert Universe(ZB) eq Algebra(I);
  if Use_in then 
    assert &and[ zb in I : zb in ZB]; 
    if IsLeftIdeal(I) then
       assert &and [zbO*zbI in I : zbO in ZBasis(O), zbI in ZB];
    end if;
    if IsRightIdeal(I) then
       assert &and [zbI*zbO in I : zbO in ZBasis(O), zbI in ZB];
    end if;
    if assigned I`LeftOrder then
       assert &and [zbO*zbI in I : zbO in ZBasis(I`LeftOrder), zbI in ZB];
    end if;
    if assigned I`RightOrder then
       assert &and [zbI*zbO in I : zbO in ZBasis(I`RightOrder), zbI in ZB];
    end if;
  end if;
  if UseLattice then 
    LO, toLO := Lattice(O);
    try LI, toLI := Lattice(I);
    catch ERR error "in CheckIdeal: the ideal is not of full rank?"; end try;
    if IsLeftIdeal(I) then
       _ := [toLI(zbO*zbI) : zbO in ZBasis(O), zbI in ZB]; // checks images are in LI
    end if;
    if IsRightIdeal(I) then
       _ := [toLI(zbI*zbO) : zbO in ZBasis(O), zbI in ZB]; // checks images are in LI
    end if;
  end if;
end intrinsic;

intrinsic IdealsAreEqual(I::., J::. : Use_in:=true, UseLattice:=false) -> BoolElt
{For debugging only. Computes 'I eq J' a different way (for ideals or orders in an AlgAssVOrd)}

  if not Use_in then UseLattice:=true; end if;
  if Use_in then
    IinJ := &and[ Algebra(J)!ii in J : ii in ZBasis(I)];
    JinI := &and[ Algebra(I)!jj in I : jj in ZBasis(J)];
    IeqJ := (IinJ and JinI);
  end if;
  if UseLattice then
    LI, toLI := Lattice(I);
    LJ, toLJ := Lattice(J);
    IinJ := &and[ toLI(ii) in LJ : ii in ZBasis(I)];
    JinI := &and[ toLJ(jj) in LI : jj in ZBasis(J)];
    if Use_in then assert IeqJ eq (IinJ and JinI);
    else IeqJ := (IinJ and JinI); end if;
  end if;
  return IeqJ;
end intrinsic;

intrinsic Determinant(M::PMat) -> .
{For debugging only. The determinant of the module.}
  return Determinant(Matrix(M)) * &* CoefficientIdeals(M);
end intrinsic;
