freeze;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Representations of Quaternion Algebras                //
//                         David R. Kohel                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

intrinsic MatrixRepresentation(A::AlgQuat) -> Map
    {Returns a 2-dimensional matrix representation over the splitting
    field generated by the first non-central basis element.}
    require Type(BaseField(A)) eq FldRat :
       "Argument must be defined over the rationals.";
    f := CharacteristicPolynomial(A.1);
    K := NumberField(f);
    MatK := MatrixAlgebra(K,2);
    i := A.1; j := A.2; k := A.3;
    B := [ 1, i, j, i*j ];
    t1 := Trace(i)/2;
    t2 := Trace(j)/2; n2 := t2^2-Norm(j);
    M0 := MatK!1;
    M1 := MatK![ K.1, 0, 0, t1-K.1 ];
    M2 := MatK![ t2, 1, n2, t2 ];
    M := Matrix(4,4,&cat[ Eltseq(x) : x in B ]);
    c := Eltseq(A.3);
    M3 := c[1]*M0 + c[2]*M1 + (c[3] + c[4]*M1)*M2;  
    MatGens := [ M0, M1, M2, M3 ];
    return hom< A -> MatK | x :->
        &+[ c[i]*MatGens[i] : i in [1..4] ]
            where c := Eltseq(x) >;
end intrinsic;

intrinsic MatrixRepresentation(R::AlgQuatOrd) -> Map
    {Returns a 2-dimensional matrix representation over the
    splitting field generated by the first non-central basis
    element of the quaternion algebra containing R.}
    A := QuaternionAlgebra(R);
    require Type(BaseField(A)) eq FldRat :
       "Argument must be defined over the integers.";
    f := MatrixRepresentation(A);
    MatK := Codomain(f);
    B := Basis(R);
    MatGens := [ f(A!x) : x in B ];
    return hom< R -> MatK | x :->
        &+[ c[i]*MatGens[i] : i in [1..4] ]
            where c := Eltseq(x) >;
end intrinsic;



